{"version":3,"file":"addFieldStatePromise.js","names":["ObjectIdImport","getBlockSelect","deepCopyObjectSimple","fieldAffectsData","fieldHasSubFields","fieldIsHiddenOrDisabled","fieldIsID","fieldIsLocalized","getFieldPaths","tabHasName","resolveFilterOptions","isRowCollapsed","iterateFields","ObjectId","default","addFieldStatePromise","args","id","addErrorPathToParent","addErrorPathToParentArg","anyParentLocalized","blockData","clientFieldSchemaMap","collectionSlug","data","field","fieldSchemaMap","filter","forceFullValue","fullData","includeSchema","indexPath","mockRSCs","omitParents","operation","parentPath","parentPermissions","parentSchemaPath","passesCondition","path","preferences","previousFormState","readOnly","renderAllFields","renderFieldFn","req","schemaPath","select","selectMode","skipConditionChecks","skipValidation","state","console","warn","fieldPermissions","fieldState","lastRenderedPath","addedByServer","fieldSchema","name","hasPermission","read","access","siblingData","validate","validationResult","jsonError","type","JSON","parse","e","event","previousValue","initialValue","err","payload","logger","error","msg","errorPath","errorPaths","includes","push","valid","errorMessage","arrayValue","Array","isArray","arraySelect","promises","rows","reduce","acc","row","i","toHexString","idKey","value","fields","find","localized","parentIndexPath","parentPassesCondition","permissions","undefined","previousRow","prevRow","newRow","isLoading","isCollapsed","collapsedPrefs","collapsed","length","Promise","all","disableFormData","blocksValue","rowMetadata","blockTypeToMatch","blockType","block","blocks","blockReferences","slug","Error","blockSelect","blockSelectMode","blockField","fieldKey","blockNameKey","blockName","groupSelect","filterOptions","relationTo","relation","query","user","hasMany","relationshipValue","map","relationship","selectFilterOptions","options","tabs","tab","tabIndex","isNamedTab","tabSelect","tabIndexPath","tabPath","tabSchemaPath","index","childPermissions","tabPermissions","pathSegments","split","tabPassesCondition","admin","condition","fieldConfig","get","endsWith","formState","previousFieldState"],"sources":["../../../src/forms/fieldSchemasToFormState/addFieldStatePromise.ts"],"sourcesContent":["import type {\n  ArrayField,\n  BlocksField,\n  BuildFormStateArgs,\n  ClientFieldSchemaMap,\n  CollapsedPreferences,\n  Data,\n  DocumentPreferences,\n  Field,\n  FieldSchemaMap,\n  FieldState,\n  FlattenedBlock,\n  FormState,\n  FormStateWithoutComponents,\n  PayloadRequest,\n  Row,\n  SanitizedFieldPermissions,\n  SanitizedFieldsPermissions,\n  SelectMode,\n  SelectType,\n  Validate,\n} from 'payload'\n\nimport ObjectIdImport from 'bson-objectid'\nimport { getBlockSelect } from 'payload'\nimport {\n  deepCopyObjectSimple,\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldIsHiddenOrDisabled,\n  fieldIsID,\n  fieldIsLocalized,\n  getFieldPaths,\n  tabHasName,\n} from 'payload/shared'\n\nimport type { RenderFieldMethod } from './types.js'\n\nimport { resolveFilterOptions } from '../../utilities/resolveFilterOptions.js'\nimport { isRowCollapsed } from './isRowCollapsed.js'\nimport { iterateFields } from './iterateFields.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport type AddFieldStatePromiseArgs = {\n  addErrorPathToParent: (fieldPath: string) => void\n  /**\n   * if all parents are localized, then the field is localized\n   */\n  anyParentLocalized?: boolean\n  /**\n   * Data of the nearest parent block, or undefined\n   */\n  blockData: Data | undefined\n  clientFieldSchemaMap?: ClientFieldSchemaMap\n  collectionSlug?: string\n  data: Data\n  field: Field\n  fieldIndex: number\n  fieldSchemaMap: FieldSchemaMap\n  /**\n   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.\n   */\n  filter?: (args: AddFieldStatePromiseArgs) => boolean\n  /**\n   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false\n   */\n  forceFullValue?: boolean\n  fullData: Data\n  id: number | string\n  /**\n   * Whether the field schema should be included in the state\n   */\n  includeSchema?: boolean\n  indexPath: string\n  mockRSCs?: BuildFormStateArgs['mockRSCs']\n  /**\n   * Whether to omit parent fields in the state. @default false\n   */\n  omitParents?: boolean\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentPath: string\n  parentPermissions: SanitizedFieldsPermissions\n  parentSchemaPath: string\n  passesCondition: boolean\n  path: string\n  preferences: DocumentPreferences\n  previousFormState: FormState\n  readOnly?: boolean\n  renderAllFields: boolean\n  renderFieldFn: RenderFieldMethod\n  /**\n   * Req is used for validation and defaultValue calculation. If you don't need validation,\n   * just create your own req and pass in the locale and the user\n   */\n  req: PayloadRequest\n  schemaPath: string\n  select?: SelectType\n  selectMode?: SelectMode\n  /**\n   * Whether to skip checking the field's condition. @default false\n   */\n  skipConditionChecks?: boolean\n  /**\n   * Whether to skip validating the field. @default false\n   */\n  skipValidation?: boolean\n  state: FormStateWithoutComponents\n}\n\n/**\n * Flattens the fields schema and fields data.\n * The output is the field path (e.g. array.0.name) mapped to a FormField object.\n */\nexport const addFieldStatePromise = async (args: AddFieldStatePromiseArgs): Promise<void> => {\n  const {\n    id,\n    addErrorPathToParent: addErrorPathToParentArg,\n    anyParentLocalized = false,\n    blockData,\n    clientFieldSchemaMap,\n    collectionSlug,\n    data,\n    field,\n    fieldSchemaMap,\n    filter,\n    forceFullValue = false,\n    fullData,\n    includeSchema = false,\n    indexPath,\n    mockRSCs,\n    omitParents = false,\n    operation,\n    parentPath,\n    parentPermissions,\n    parentSchemaPath,\n    passesCondition,\n    path,\n    preferences,\n    previousFormState,\n    readOnly,\n    renderAllFields,\n    renderFieldFn,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipConditionChecks = false,\n    skipValidation = false,\n    state,\n  } = args\n\n  if (!args.clientFieldSchemaMap && args.renderFieldFn) {\n    console.warn(\n      'clientFieldSchemaMap is not passed to addFieldStatePromise - this will reduce performance',\n    )\n  }\n\n  let fieldPermissions: SanitizedFieldPermissions = true\n\n  const fieldState: FieldState = {}\n\n  const lastRenderedPath = previousFormState?.[path]?.lastRenderedPath\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (lastRenderedPath) {\n    fieldState.lastRenderedPath = lastRenderedPath\n  }\n\n  // If we're rendering all fields, no need to flag this as added by server\n  const addedByServer = !renderAllFields && !previousFormState?.[path]\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (addedByServer) {\n    fieldState.addedByServer = true\n  }\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (passesCondition === false) {\n    fieldState.passesCondition = false\n  }\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (includeSchema) {\n    fieldState.fieldSchema = field\n  }\n\n  if (fieldAffectsData(field) && !fieldIsHiddenOrDisabled(field)) {\n    fieldPermissions =\n      parentPermissions === true\n        ? parentPermissions\n        : deepCopyObjectSimple(parentPermissions?.[field.name])\n\n    let hasPermission: boolean =\n      fieldPermissions === true || deepCopyObjectSimple(fieldPermissions?.read)\n\n    if (typeof field?.access?.read === 'function') {\n      hasPermission = await field.access.read({\n        id,\n        blockData,\n        data: fullData,\n        req,\n        siblingData: data,\n      })\n    } else {\n      hasPermission = true\n    }\n\n    if (!hasPermission) {\n      return\n    }\n\n    const validate: Validate = field.validate\n\n    let validationResult: string | true = true\n\n    if (typeof validate === 'function' && !skipValidation && passesCondition) {\n      let jsonError\n\n      if (field.type === 'json' && typeof data[field.name] === 'string') {\n        try {\n          JSON.parse(data[field.name])\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      try {\n        validationResult = await validate(data?.[field.name], {\n          ...field,\n          id,\n          blockData,\n          collectionSlug,\n          data: fullData,\n          event: 'onChange',\n          // @AlessioGr added `jsonError` in https://github.com/payloadcms/payload/commit/c7ea62a39473408c3ea912c4fbf73e11be4b538d\n          // @ts-expect-error-next-line\n          jsonError,\n          operation,\n          preferences,\n          previousValue: previousFormState?.[path]?.initialValue,\n          req,\n          siblingData: data,\n        })\n      } catch (err) {\n        validationResult = `Error validating field at path: ${path}`\n\n        req.payload.logger.error({\n          err,\n          msg: validationResult,\n        })\n      }\n    }\n\n    const addErrorPathToParent = (errorPath: string) => {\n      if (typeof addErrorPathToParentArg === 'function') {\n        addErrorPathToParentArg(errorPath)\n      }\n\n      if (!fieldState.errorPaths) {\n        fieldState.errorPaths = []\n      }\n\n      if (!fieldState.errorPaths.includes(errorPath)) {\n        fieldState.errorPaths.push(errorPath)\n        fieldState.valid = false\n      }\n    }\n\n    if (typeof validationResult === 'string') {\n      fieldState.errorMessage = validationResult\n      fieldState.valid = false\n      addErrorPathToParent(path)\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const arrayValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        const arraySelect = select?.[field.name]\n\n        const { promises, rows } = arrayValue.reduce(\n          (acc, row, i: number) => {\n            const parentPath = path + '.' + i\n            row.id = row?.id || new ObjectId().toHexString()\n\n            if (!omitParents && (!filter || filter(args))) {\n              const idKey = parentPath + '.id'\n\n              state[idKey] = {\n                initialValue: row.id,\n                value: row.id,\n              }\n\n              if (includeSchema) {\n                state[idKey].fieldSchema = field.fields.find((field) => fieldIsID(field))\n              }\n            }\n\n            acc.promises.push(\n              iterateFields({\n                id,\n                addErrorPathToParent,\n                anyParentLocalized: field.localized || anyParentLocalized,\n                blockData,\n                clientFieldSchemaMap,\n                collectionSlug,\n                data: row,\n                fields: field.fields,\n                fieldSchemaMap,\n                filter,\n                forceFullValue,\n                fullData,\n                includeSchema,\n                mockRSCs,\n                omitParents,\n                operation,\n                parentIndexPath: '',\n                parentPassesCondition: passesCondition,\n                parentPath,\n                parentSchemaPath: schemaPath,\n                permissions:\n                  fieldPermissions === true ? fieldPermissions : fieldPermissions?.fields || {},\n                preferences,\n                previousFormState,\n                readOnly,\n                renderAllFields,\n                renderFieldFn,\n                req,\n                select: typeof arraySelect === 'object' ? arraySelect : undefined,\n                selectMode,\n                skipConditionChecks,\n                skipValidation,\n                state,\n              }),\n            )\n\n            if (!acc.rows) {\n              acc.rows = []\n            }\n\n            // First, check if `previousFormState` has a matching row\n            const previousRow: Row = (previousFormState?.[path]?.rows || []).find(\n              (prevRow) => prevRow.id === row.id,\n            )\n\n            const newRow: Row = {\n              id: row.id,\n              isLoading: false,\n            }\n\n            if (previousRow?.lastRenderedPath) {\n              newRow.lastRenderedPath = previousRow.lastRenderedPath\n            }\n\n            acc.rows.push(newRow)\n\n            const isCollapsed = isRowCollapsed({\n              collapsedPrefs: preferences?.fields?.[path]?.collapsed,\n              field,\n              previousRow,\n              row,\n            })\n\n            if (isCollapsed) {\n              acc.rows[acc.rows.length - 1].collapsed = true\n            }\n\n            return acc\n          },\n          {\n            promises: [],\n            rows: undefined,\n          },\n        )\n\n        // Wait for all promises and update fields with the results\n        await Promise.all(promises)\n\n        if (rows) {\n          fieldState.rows = rows\n        }\n\n        // Add values to field state\n        if (data[field.name] !== null) {\n          fieldState.value = forceFullValue ? arrayValue : arrayValue.length\n          fieldState.initialValue = forceFullValue ? arrayValue : arrayValue.length\n\n          if (arrayValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        const { promises, rowMetadata } = blocksValue.reduce(\n          (acc, row, i: number) => {\n            const blockTypeToMatch: string = row.blockType\n\n            const block =\n              req.payload.blocks[blockTypeToMatch] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (blockType) => typeof blockType !== 'string' && blockType.slug === blockTypeToMatch,\n              ) as FlattenedBlock | undefined)\n\n            if (!block) {\n              throw new Error(\n                `Block with type \"${row.blockType}\" was found in block data, but no block with that type is defined in the config for field with schema path ${schemaPath}.`,\n              )\n            }\n\n            const { blockSelect, blockSelectMode } = getBlockSelect({\n              block,\n              select: select?.[field.name],\n              selectMode,\n            })\n\n            const parentPath = path + '.' + i\n\n            if (block) {\n              row.id = row?.id || new ObjectId().toHexString()\n\n              if (!omitParents && (!filter || filter(args))) {\n                // Handle block `id` field\n                const idKey = parentPath + '.id'\n\n                state[idKey] = {\n                  initialValue: row.id,\n                  value: row.id,\n                }\n\n                if (includeSchema) {\n                  state[idKey].fieldSchema = includeSchema\n                    ? block.fields.find((blockField) => fieldIsID(blockField))\n                    : undefined\n                }\n\n                // Handle `blockType` field\n                const fieldKey = parentPath + '.blockType'\n\n                state[fieldKey] = {\n                  initialValue: row.blockType,\n                  value: row.blockType,\n                }\n\n                if (addedByServer) {\n                  state[fieldKey].addedByServer = addedByServer\n                }\n\n                if (includeSchema) {\n                  state[fieldKey].fieldSchema = block.fields.find(\n                    (blockField) => 'name' in blockField && blockField.name === 'blockType',\n                  )\n                }\n\n                // Handle `blockName` field\n                const blockNameKey = parentPath + '.blockName'\n\n                state[blockNameKey] = {}\n\n                if (row.blockName) {\n                  state[blockNameKey].initialValue = row.blockName\n                  state[blockNameKey].value = row.blockName\n                }\n\n                if (includeSchema) {\n                  state[blockNameKey].fieldSchema = block.fields.find(\n                    (blockField) => 'name' in blockField && blockField.name === 'blockName',\n                  )\n                }\n              }\n\n              acc.promises.push(\n                iterateFields({\n                  id,\n                  addErrorPathToParent,\n                  anyParentLocalized: field.localized || anyParentLocalized,\n                  blockData: row,\n                  clientFieldSchemaMap,\n                  collectionSlug,\n                  data: row,\n                  fields: block.fields,\n                  fieldSchemaMap,\n                  filter,\n                  forceFullValue,\n                  fullData,\n                  includeSchema,\n                  mockRSCs,\n                  omitParents,\n                  operation,\n                  parentIndexPath: '',\n                  parentPassesCondition: passesCondition,\n                  parentPath,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  permissions:\n                    fieldPermissions === true\n                      ? fieldPermissions\n                      : parentPermissions?.[field.name]?.blocks?.[block.slug] === true\n                        ? true\n                        : parentPermissions?.[field.name]?.blocks?.[block.slug]?.fields || {},\n                  preferences,\n                  previousFormState,\n                  readOnly,\n                  renderAllFields,\n                  renderFieldFn,\n                  req,\n                  select: typeof blockSelect === 'object' ? blockSelect : undefined,\n                  selectMode: blockSelectMode,\n                  skipConditionChecks,\n                  skipValidation,\n                  state,\n                }),\n              )\n\n              // First, check if `previousFormState` has a matching row\n              const previousRow: Row = (previousFormState?.[path]?.rows || []).find(\n                (prevRow) => prevRow.id === row.id,\n              )\n\n              const newRow: Row = {\n                id: row.id,\n                blockType: row.blockType,\n                isLoading: false,\n              }\n\n              if (previousRow?.lastRenderedPath) {\n                newRow.lastRenderedPath = previousRow.lastRenderedPath\n              }\n\n              acc.rowMetadata.push(newRow)\n\n              const isCollapsed = isRowCollapsed({\n                collapsedPrefs: preferences?.fields?.[path]?.collapsed,\n                field,\n                previousRow,\n                row,\n              })\n\n              if (isCollapsed) {\n                acc.rowMetadata[acc.rowMetadata.length - 1].collapsed = true\n              }\n            }\n\n            return acc\n          },\n          {\n            promises: [],\n            rowMetadata: [],\n          },\n        )\n\n        await Promise.all(promises)\n\n        // Add values to field state\n        if (data[field.name] === null) {\n          fieldState.value = null\n          fieldState.initialValue = null\n        } else {\n          fieldState.value = forceFullValue ? blocksValue : blocksValue.length\n          fieldState.initialValue = forceFullValue ? blocksValue : blocksValue.length\n\n          if (blocksValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        fieldState.rows = rowMetadata\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'group': {\n        if (!filter || filter(args)) {\n          fieldState.disableFormData = true\n          state[path] = fieldState\n        }\n\n        const groupSelect = select?.[field.name]\n\n        await iterateFields({\n          id,\n          addErrorPathToParent,\n          anyParentLocalized: field.localized || anyParentLocalized,\n          blockData,\n          clientFieldSchemaMap,\n          collectionSlug,\n          data: data?.[field.name] || {},\n          fields: field.fields,\n          fieldSchemaMap,\n          filter,\n          forceFullValue,\n          fullData,\n          includeSchema,\n          mockRSCs,\n          omitParents,\n          operation,\n          parentIndexPath: '',\n          parentPassesCondition: passesCondition,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          permissions:\n            typeof fieldPermissions === 'boolean' ? fieldPermissions : fieldPermissions?.fields,\n          preferences,\n          previousFormState,\n          readOnly,\n          renderAllFields,\n          renderFieldFn,\n          req,\n          select: typeof groupSelect === 'object' ? groupSelect : undefined,\n          selectMode,\n          skipConditionChecks,\n          skipValidation,\n          state,\n        })\n\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        if (field.filterOptions) {\n          if (typeof field.filterOptions === 'object') {\n            if (typeof field.relationTo === 'string') {\n              fieldState.filterOptions = {\n                [field.relationTo]: field.filterOptions,\n              }\n            } else {\n              fieldState.filterOptions = field.relationTo.reduce((acc, relation) => {\n                acc[relation] = field.filterOptions\n                return acc\n              }, {})\n            }\n          }\n\n          if (typeof field.filterOptions === 'function') {\n            const query = await resolveFilterOptions(field.filterOptions, {\n              id,\n              blockData,\n              data: fullData,\n              relationTo: field.relationTo,\n              req,\n              siblingData: data,\n              user: req.user,\n            })\n\n            fieldState.filterOptions = query\n          }\n        }\n\n        if (field.hasMany) {\n          const relationshipValue = Array.isArray(data[field.name])\n            ? data[field.name].map((relationship) => {\n                if (Array.isArray(field.relationTo)) {\n                  return {\n                    relationTo: relationship.relationTo,\n                    value:\n                      relationship.value && typeof relationship.value === 'object'\n                        ? relationship.value?.id\n                        : relationship.value,\n                  }\n                }\n                if (typeof relationship === 'object' && relationship !== null) {\n                  return relationship.id\n                }\n                return relationship\n              })\n            : undefined\n\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        } else if (Array.isArray(field.relationTo)) {\n          if (\n            data[field.name] &&\n            typeof data[field.name] === 'object' &&\n            'relationTo' in data[field.name] &&\n            'value' in data[field.name]\n          ) {\n            const value =\n              typeof data[field.name]?.value === 'object' &&\n              data[field.name]?.value &&\n              'id' in data[field.name].value\n                ? data[field.name].value.id\n                : data[field.name].value\n            const relationshipValue = {\n              relationTo: data[field.name]?.relationTo,\n              value,\n            }\n            fieldState.value = relationshipValue\n            fieldState.initialValue = relationshipValue\n          }\n        } else {\n          const relationshipValue =\n            data[field.name] && typeof data[field.name] === 'object' && 'id' in data[field.name]\n              ? data[field.name].id\n              : data[field.name]\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        }\n\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'select': {\n        if (typeof field.filterOptions === 'function') {\n          fieldState.selectFilterOptions = field.filterOptions({\n            data: fullData,\n            options: field.options,\n            req,\n            siblingData: data,\n          })\n        }\n\n        if (data[field.name] !== undefined) {\n          fieldState.value = data[field.name]\n          fieldState.initialValue = data[field.name]\n        }\n\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      default: {\n        if (data[field.name] !== undefined) {\n          fieldState.value = data[field.name]\n          fieldState.initialValue = data[field.name]\n        }\n\n        // Add field to state\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n    }\n  } else if (fieldHasSubFields(field) && !fieldAffectsData(field)) {\n    // Handle field types that do not use names (row, collapsible, unnamed group etc)\n\n    if (!filter || filter(args)) {\n      state[path] = {\n        disableFormData: true,\n      }\n\n      if (passesCondition === false) {\n        state[path].passesCondition = false\n      }\n    }\n\n    await iterateFields({\n      id,\n      mockRSCs,\n      select,\n      selectMode,\n      // passthrough parent functionality\n      addErrorPathToParent: addErrorPathToParentArg,\n      anyParentLocalized: fieldIsLocalized(field) || anyParentLocalized,\n      blockData,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data,\n      fields: field.fields,\n      fieldSchemaMap,\n      filter,\n      forceFullValue,\n      fullData,\n      includeSchema,\n      omitParents,\n      operation,\n      parentIndexPath: indexPath,\n      parentPassesCondition: passesCondition,\n      parentPath,\n      parentSchemaPath,\n      permissions: parentPermissions, // TODO: Verify this is correct\n      preferences,\n      previousFormState,\n      readOnly,\n      renderAllFields,\n      renderFieldFn,\n      req,\n      skipConditionChecks,\n      skipValidation,\n      state,\n    })\n  } else if (field.type === 'tabs') {\n    const promises = field.tabs.map((tab, tabIndex) => {\n      const isNamedTab = tabHasName(tab)\n      let tabSelect: SelectType | undefined\n\n      const {\n        indexPath: tabIndexPath,\n        path: tabPath,\n        schemaPath: tabSchemaPath,\n      } = getFieldPaths({\n        field: {\n          ...tab,\n          type: 'tab',\n        },\n        index: tabIndex,\n        parentIndexPath: indexPath,\n        parentPath,\n        parentSchemaPath,\n      })\n\n      let childPermissions: SanitizedFieldsPermissions = undefined\n\n      if (isNamedTab) {\n        if (parentPermissions === true) {\n          childPermissions = true\n        } else {\n          const tabPermissions = parentPermissions?.[tab.name]\n          if (tabPermissions === true) {\n            childPermissions = true\n          } else {\n            childPermissions = tabPermissions?.fields\n          }\n        }\n\n        if (typeof select?.[tab.name] === 'object') {\n          tabSelect = select?.[tab.name] as SelectType\n        }\n      } else {\n        childPermissions = parentPermissions\n        tabSelect = select\n      }\n\n      const pathSegments = path ? path.split('.') : []\n\n      // If passesCondition is false then this should always result to false\n      // If the tab has no admin.condition provided then fallback to passesCondition and let that decide the result\n      let tabPassesCondition = passesCondition\n\n      if (passesCondition && typeof tab.admin?.condition === 'function') {\n        tabPassesCondition = tab.admin.condition(fullData, data, {\n          blockData,\n          operation,\n          path: pathSegments,\n          user: req.user,\n        })\n      }\n\n      if (tab?.id) {\n        state[tab.id] = {\n          passesCondition: tabPassesCondition,\n        }\n      }\n\n      return iterateFields({\n        id,\n        addErrorPathToParent: addErrorPathToParentArg,\n        anyParentLocalized: tab.localized || anyParentLocalized,\n        blockData,\n        clientFieldSchemaMap,\n        collectionSlug,\n        data: isNamedTab ? data?.[tab.name] || {} : data,\n        fields: tab.fields,\n        fieldSchemaMap,\n        filter,\n        forceFullValue,\n        fullData,\n        includeSchema,\n        mockRSCs,\n        omitParents,\n        operation,\n        parentIndexPath: isNamedTab ? '' : tabIndexPath,\n        parentPassesCondition: tabPassesCondition,\n        parentPath: isNamedTab ? tabPath : parentPath,\n        parentSchemaPath: isNamedTab ? tabSchemaPath : parentSchemaPath,\n        permissions: childPermissions,\n        preferences,\n        previousFormState,\n        readOnly,\n        renderAllFields,\n        renderFieldFn,\n        req,\n        select: tabSelect,\n        selectMode,\n        skipConditionChecks,\n        skipValidation,\n        state,\n      })\n    })\n\n    await Promise.all(promises)\n  } else if (field.type === 'ui') {\n    if (!filter || filter(args)) {\n      state[path] = fieldState\n      state[path].disableFormData = true\n    }\n  }\n\n  if (renderFieldFn && !fieldIsHiddenOrDisabled(field)) {\n    const fieldConfig = fieldSchemaMap.get(schemaPath)\n\n    if (!fieldConfig && !mockRSCs) {\n      if (schemaPath.endsWith('.blockType')) {\n        return\n      } else {\n        throw new Error(`Field config not found for ${schemaPath}`)\n      }\n    }\n\n    if (!state[path]) {\n      // Some fields (ie `Tab`) do not live in form state\n      // therefore we cannot attach customComponents to them\n      return\n    }\n\n    if (addedByServer) {\n      state[path].addedByServer = addedByServer\n    }\n\n    renderFieldFn({\n      id,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data: fullData,\n      fieldConfig: fieldConfig as Field,\n      fieldSchemaMap,\n      fieldState: state[path],\n      formState: state,\n      indexPath,\n      lastRenderedPath,\n      mockRSCs,\n      operation,\n      parentPath,\n      parentSchemaPath,\n      path,\n      permissions: fieldPermissions,\n      preferences,\n      previousFieldState: previousFormState?.[path],\n      readOnly,\n      renderAllFields,\n      req,\n      schemaPath,\n      siblingData: data,\n    })\n  }\n}\n"],"mappings":"AAuBA,OAAOA,cAAA,MAAoB;AAC3B,SAASC,cAAc,QAAQ;AAC/B,SACEC,oBAAoB,EACpBC,gBAAgB,EAChBC,iBAAiB,EACjBC,uBAAuB,EACvBC,SAAS,EACTC,gBAAgB,EAChBC,aAAa,EACbC,UAAU,QACL;AAIP,SAASC,oBAAoB,QAAQ;AACrC,SAASC,cAAc,QAAQ;AAC/B,SAASC,aAAa,QAAQ;AAE9B,MAAMC,QAAA,GAAYb,cAAA,CAAec,OAAO,IACtCd,cAAA;AAqEF;;;;AAIA,OAAO,MAAMe,oBAAA,GAAuB,MAAOC,IAAA;EACzC,MAAM;IACJC,EAAE;IACFC,oBAAA,EAAsBC,uBAAuB;IAC7CC,kBAAA,GAAqB,KAAK;IAC1BC,SAAS;IACTC,oBAAoB;IACpBC,cAAc;IACdC,IAAI;IACJC,KAAK;IACLC,cAAc;IACdC,MAAM;IACNC,cAAA,GAAiB,KAAK;IACtBC,QAAQ;IACRC,aAAA,GAAgB,KAAK;IACrBC,SAAS;IACTC,QAAQ;IACRC,WAAA,GAAc,KAAK;IACnBC,SAAS;IACTC,UAAU;IACVC,iBAAiB;IACjBC,gBAAgB;IAChBC,eAAe;IACfC,IAAI;IACJC,WAAW;IACXC,iBAAiB;IACjBC,QAAQ;IACRC,eAAe;IACfC,aAAa;IACbC,GAAG;IACHC,UAAU;IACVC,MAAM;IACNC,UAAU;IACVC,mBAAA,GAAsB,KAAK;IAC3BC,cAAA,GAAiB,KAAK;IACtBC;EAAK,CACN,GAAGnC,IAAA;EAEJ,IAAI,CAACA,IAAA,CAAKM,oBAAoB,IAAIN,IAAA,CAAK4B,aAAa,EAAE;IACpDQ,OAAA,CAAQC,IAAI,CACV;EAEJ;EAEA,IAAIC,gBAAA,GAA8C;EAElD,MAAMC,UAAA,GAAyB,CAAC;EAEhC,MAAMC,gBAAA,GAAmBf,iBAAA,GAAoBF,IAAA,CAAK,EAAEiB,gBAAA;EAEpD;EACA,IAAIA,gBAAA,EAAkB;IACpBD,UAAA,CAAWC,gBAAgB,GAAGA,gBAAA;EAChC;EAEA;EACA,MAAMC,aAAA,GAAgB,CAACd,eAAA,IAAmB,CAACF,iBAAA,GAAoBF,IAAA,CAAK;EAEpE;EACA,IAAIkB,aAAA,EAAe;IACjBF,UAAA,CAAWE,aAAa,GAAG;EAC7B;EAEA;EACA,IAAInB,eAAA,KAAoB,OAAO;IAC7BiB,UAAA,CAAWjB,eAAe,GAAG;EAC/B;EAEA;EACA,IAAIR,aAAA,EAAe;IACjByB,UAAA,CAAWG,WAAW,GAAGjC,KAAA;EAC3B;EAEA,IAAItB,gBAAA,CAAiBsB,KAAA,KAAU,CAACpB,uBAAA,CAAwBoB,KAAA,GAAQ;IAC9D6B,gBAAA,GACElB,iBAAA,KAAsB,OAClBA,iBAAA,GACAlC,oBAAA,CAAqBkC,iBAAA,GAAoBX,KAAA,CAAMkC,IAAI,CAAC;IAE1D,IAAIC,aAAA,GACFN,gBAAA,KAAqB,QAAQpD,oBAAA,CAAqBoD,gBAAA,EAAkBO,IAAA;IAEtE,IAAI,OAAOpC,KAAA,EAAOqC,MAAA,EAAQD,IAAA,KAAS,YAAY;MAC7CD,aAAA,GAAgB,MAAMnC,KAAA,CAAMqC,MAAM,CAACD,IAAI,CAAC;QACtC5C,EAAA;QACAI,SAAA;QACAG,IAAA,EAAMK,QAAA;QACNgB,GAAA;QACAkB,WAAA,EAAavC;MACf;IACF,OAAO;MACLoC,aAAA,GAAgB;IAClB;IAEA,IAAI,CAACA,aAAA,EAAe;MAClB;IACF;IAEA,MAAMI,QAAA,GAAqBvC,KAAA,CAAMuC,QAAQ;IAEzC,IAAIC,gBAAA,GAAkC;IAEtC,IAAI,OAAOD,QAAA,KAAa,cAAc,CAACd,cAAA,IAAkBZ,eAAA,EAAiB;MACxE,IAAI4B,SAAA;MAEJ,IAAIzC,KAAA,CAAM0C,IAAI,KAAK,UAAU,OAAO3C,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,KAAK,UAAU;QACjE,IAAI;UACFS,IAAA,CAAKC,KAAK,CAAC7C,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC;QAC7B,EAAE,OAAOW,CAAA,EAAG;UACVJ,SAAA,GAAYI,CAAA;QACd;MACF;MAEA,IAAI;QACFL,gBAAA,GAAmB,MAAMD,QAAA,CAASxC,IAAA,GAAOC,KAAA,CAAMkC,IAAI,CAAC,EAAE;UACpD,GAAGlC,KAAK;UACRR,EAAA;UACAI,SAAA;UACAE,cAAA;UACAC,IAAA,EAAMK,QAAA;UACN0C,KAAA,EAAO;UACP;UACA;UACAL,SAAA;UACAhC,SAAA;UACAM,WAAA;UACAgC,aAAA,EAAe/B,iBAAA,GAAoBF,IAAA,CAAK,EAAEkC,YAAA;UAC1C5B,GAAA;UACAkB,WAAA,EAAavC;QACf;MACF,EAAE,OAAOkD,GAAA,EAAK;QACZT,gBAAA,GAAmB,mCAAmC1B,IAAA,EAAM;QAE5DM,GAAA,CAAI8B,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;UACvBH,GAAA;UACAI,GAAA,EAAKb;QACP;MACF;IACF;IAEA,MAAM/C,oBAAA,GAAwB6D,SAAA;MAC5B,IAAI,OAAO5D,uBAAA,KAA4B,YAAY;QACjDA,uBAAA,CAAwB4D,SAAA;MAC1B;MAEA,IAAI,CAACxB,UAAA,CAAWyB,UAAU,EAAE;QAC1BzB,UAAA,CAAWyB,UAAU,GAAG,EAAE;MAC5B;MAEA,IAAI,CAACzB,UAAA,CAAWyB,UAAU,CAACC,QAAQ,CAACF,SAAA,GAAY;QAC9CxB,UAAA,CAAWyB,UAAU,CAACE,IAAI,CAACH,SAAA;QAC3BxB,UAAA,CAAW4B,KAAK,GAAG;MACrB;IACF;IAEA,IAAI,OAAOlB,gBAAA,KAAqB,UAAU;MACxCV,UAAA,CAAW6B,YAAY,GAAGnB,gBAAA;MAC1BV,UAAA,CAAW4B,KAAK,GAAG;MACnBjE,oBAAA,CAAqBqB,IAAA;IACvB;IAEA,QAAQd,KAAA,CAAM0C,IAAI;MAChB,KAAK;QAAS;UACZ,MAAMkB,UAAA,GAAaC,KAAA,CAAMC,OAAO,CAAC/D,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,IAAInC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,GAAG,EAAE;UAE1E,MAAM6B,WAAA,GAAczC,MAAA,GAAStB,KAAA,CAAMkC,IAAI,CAAC;UAExC,MAAM;YAAE8B,QAAQ;YAAEC;UAAI,CAAE,GAAGL,UAAA,CAAWM,MAAM,CAC1C,CAACC,GAAA,EAAKC,GAAA,EAAKC,CAAA;YACT,MAAM3D,UAAA,GAAaI,IAAA,GAAO,MAAMuD,CAAA;YAChCD,GAAA,CAAI5E,EAAE,GAAG4E,GAAA,EAAK5E,EAAA,IAAM,IAAIJ,QAAA,GAAWkF,WAAW;YAE9C,IAAI,CAAC9D,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;cAC7C,MAAMgF,KAAA,GAAQ7D,UAAA,GAAa;cAE3BgB,KAAK,CAAC6C,KAAA,CAAM,GAAG;gBACbvB,YAAA,EAAcoB,GAAA,CAAI5E,EAAE;gBACpBgF,KAAA,EAAOJ,GAAA,CAAI5E;cACb;cAEA,IAAIa,aAAA,EAAe;gBACjBqB,KAAK,CAAC6C,KAAA,CAAM,CAACtC,WAAW,GAAGjC,KAAA,CAAMyE,MAAM,CAACC,IAAI,CAAE1E,KAAA,IAAUnB,SAAA,CAAUmB,KAAA;cACpE;YACF;YAEAmE,GAAA,CAAIH,QAAQ,CAACP,IAAI,CACftE,aAAA,CAAc;cACZK,EAAA;cACAC,oBAAA;cACAE,kBAAA,EAAoBK,KAAA,CAAM2E,SAAS,IAAIhF,kBAAA;cACvCC,SAAA;cACAC,oBAAA;cACAC,cAAA;cACAC,IAAA,EAAMqE,GAAA;cACNK,MAAA,EAAQzE,KAAA,CAAMyE,MAAM;cACpBxE,cAAA;cACAC,MAAA;cACAC,cAAA;cACAC,QAAA;cACAC,aAAA;cACAE,QAAA;cACAC,WAAA;cACAC,SAAA;cACAmE,eAAA,EAAiB;cACjBC,qBAAA,EAAuBhE,eAAA;cACvBH,UAAA;cACAE,gBAAA,EAAkBS,UAAA;cAClByD,WAAA,EACEjD,gBAAA,KAAqB,OAAOA,gBAAA,GAAmBA,gBAAA,EAAkB4C,MAAA,IAAU,CAAC;cAC9E1D,WAAA;cACAC,iBAAA;cACAC,QAAA;cACAC,eAAA;cACAC,aAAA;cACAC,GAAA;cACAE,MAAA,EAAQ,OAAOyC,WAAA,KAAgB,WAAWA,WAAA,GAAcgB,SAAA;cACxDxD,UAAA;cACAC,mBAAA;cACAC,cAAA;cACAC;YACF;YAGF,IAAI,CAACyC,GAAA,CAAIF,IAAI,EAAE;cACbE,GAAA,CAAIF,IAAI,GAAG,EAAE;YACf;YAEA;YACA,MAAMe,WAAA,GAAmB,CAAChE,iBAAA,GAAoBF,IAAA,CAAK,EAAEmD,IAAA,IAAQ,EAAE,EAAES,IAAI,CAClEO,OAAA,IAAYA,OAAA,CAAQzF,EAAE,KAAK4E,GAAA,CAAI5E,EAAE;YAGpC,MAAM0F,MAAA,GAAc;cAClB1F,EAAA,EAAI4E,GAAA,CAAI5E,EAAE;cACV2F,SAAA,EAAW;YACb;YAEA,IAAIH,WAAA,EAAajD,gBAAA,EAAkB;cACjCmD,MAAA,CAAOnD,gBAAgB,GAAGiD,WAAA,CAAYjD,gBAAgB;YACxD;YAEAoC,GAAA,CAAIF,IAAI,CAACR,IAAI,CAACyB,MAAA;YAEd,MAAME,WAAA,GAAclG,cAAA,CAAe;cACjCmG,cAAA,EAAgBtE,WAAA,EAAa0D,MAAA,GAAS3D,IAAA,CAAK,EAAEwE,SAAA;cAC7CtF,KAAA;cACAgF,WAAA;cACAZ;YACF;YAEA,IAAIgB,WAAA,EAAa;cACfjB,GAAA,CAAIF,IAAI,CAACE,GAAA,CAAIF,IAAI,CAACsB,MAAM,GAAG,EAAE,CAACD,SAAS,GAAG;YAC5C;YAEA,OAAOnB,GAAA;UACT,GACA;YACEH,QAAA,EAAU,EAAE;YACZC,IAAA,EAAMc;UACR;UAGF;UACA,MAAMS,OAAA,CAAQC,GAAG,CAACzB,QAAA;UAElB,IAAIC,IAAA,EAAM;YACRnC,UAAA,CAAWmC,IAAI,GAAGA,IAAA;UACpB;UAEA;UACA,IAAIlE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,KAAK,MAAM;YAC7BJ,UAAA,CAAW0C,KAAK,GAAGrE,cAAA,GAAiByD,UAAA,GAAaA,UAAA,CAAW2B,MAAM;YAClEzD,UAAA,CAAWkB,YAAY,GAAG7C,cAAA,GAAiByD,UAAA,GAAaA,UAAA,CAAW2B,MAAM;YAEzE,IAAI3B,UAAA,CAAW2B,MAAM,GAAG,GAAG;cACzBzD,UAAA,CAAW4D,eAAe,GAAG;YAC/B;UACF;UAEA;UACA,IAAI,CAAClF,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;YAC7CmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA,KAAK;QAAU;UACb,MAAM6D,WAAA,GAAc9B,KAAA,CAAMC,OAAO,CAAC/D,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,IAAInC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,GAAG,EAAE;UAE3E,MAAM;YAAE8B,QAAQ;YAAE4B;UAAW,CAAE,GAAGD,WAAA,CAAYzB,MAAM,CAClD,CAACC,GAAA,EAAKC,GAAA,EAAKC,CAAA;YACT,MAAMwB,gBAAA,GAA2BzB,GAAA,CAAI0B,SAAS;YAE9C,MAAMC,KAAA,GACJ3E,GAAA,CAAI8B,OAAO,CAAC8C,MAAM,CAACH,gBAAA,CAAiB,IACnC,CAAC7F,KAAA,CAAMiG,eAAe,IAAIjG,KAAA,CAAMgG,MAAM,EAAEtB,IAAI,CAC1CoB,SAAA,IAAc,OAAOA,SAAA,KAAc,YAAYA,SAAA,CAAUI,IAAI,KAAKL,gBAAA;YAGvE,IAAI,CAACE,KAAA,EAAO;cACV,MAAM,IAAII,KAAA,CACR,oBAAoB/B,GAAA,CAAI0B,SAAS,8GAA8GzE,UAAA,GAAa;YAEhK;YAEA,MAAM;cAAE+E,WAAW;cAAEC;YAAe,CAAE,GAAG7H,cAAA,CAAe;cACtDuH,KAAA;cACAzE,MAAA,EAAQA,MAAA,GAAStB,KAAA,CAAMkC,IAAI,CAAC;cAC5BX;YACF;YAEA,MAAMb,UAAA,GAAaI,IAAA,GAAO,MAAMuD,CAAA;YAEhC,IAAI0B,KAAA,EAAO;cACT3B,GAAA,CAAI5E,EAAE,GAAG4E,GAAA,EAAK5E,EAAA,IAAM,IAAIJ,QAAA,GAAWkF,WAAW;cAE9C,IAAI,CAAC9D,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;gBAC7C;gBACA,MAAMgF,KAAA,GAAQ7D,UAAA,GAAa;gBAE3BgB,KAAK,CAAC6C,KAAA,CAAM,GAAG;kBACbvB,YAAA,EAAcoB,GAAA,CAAI5E,EAAE;kBACpBgF,KAAA,EAAOJ,GAAA,CAAI5E;gBACb;gBAEA,IAAIa,aAAA,EAAe;kBACjBqB,KAAK,CAAC6C,KAAA,CAAM,CAACtC,WAAW,GAAG5B,aAAA,GACvB0F,KAAA,CAAMtB,MAAM,CAACC,IAAI,CAAE4B,UAAA,IAAezH,SAAA,CAAUyH,UAAA,KAC5CvB,SAAA;gBACN;gBAEA;gBACA,MAAMwB,QAAA,GAAW7F,UAAA,GAAa;gBAE9BgB,KAAK,CAAC6E,QAAA,CAAS,GAAG;kBAChBvD,YAAA,EAAcoB,GAAA,CAAI0B,SAAS;kBAC3BtB,KAAA,EAAOJ,GAAA,CAAI0B;gBACb;gBAEA,IAAI9D,aAAA,EAAe;kBACjBN,KAAK,CAAC6E,QAAA,CAAS,CAACvE,aAAa,GAAGA,aAAA;gBAClC;gBAEA,IAAI3B,aAAA,EAAe;kBACjBqB,KAAK,CAAC6E,QAAA,CAAS,CAACtE,WAAW,GAAG8D,KAAA,CAAMtB,MAAM,CAACC,IAAI,CAC5C4B,UAAA,IAAe,UAAUA,UAAA,IAAcA,UAAA,CAAWpE,IAAI,KAAK;gBAEhE;gBAEA;gBACA,MAAMsE,YAAA,GAAe9F,UAAA,GAAa;gBAElCgB,KAAK,CAAC8E,YAAA,CAAa,GAAG,CAAC;gBAEvB,IAAIpC,GAAA,CAAIqC,SAAS,EAAE;kBACjB/E,KAAK,CAAC8E,YAAA,CAAa,CAACxD,YAAY,GAAGoB,GAAA,CAAIqC,SAAS;kBAChD/E,KAAK,CAAC8E,YAAA,CAAa,CAAChC,KAAK,GAAGJ,GAAA,CAAIqC,SAAS;gBAC3C;gBAEA,IAAIpG,aAAA,EAAe;kBACjBqB,KAAK,CAAC8E,YAAA,CAAa,CAACvE,WAAW,GAAG8D,KAAA,CAAMtB,MAAM,CAACC,IAAI,CAChD4B,UAAA,IAAe,UAAUA,UAAA,IAAcA,UAAA,CAAWpE,IAAI,KAAK;gBAEhE;cACF;cAEAiC,GAAA,CAAIH,QAAQ,CAACP,IAAI,CACftE,aAAA,CAAc;gBACZK,EAAA;gBACAC,oBAAA;gBACAE,kBAAA,EAAoBK,KAAA,CAAM2E,SAAS,IAAIhF,kBAAA;gBACvCC,SAAA,EAAWwE,GAAA;gBACXvE,oBAAA;gBACAC,cAAA;gBACAC,IAAA,EAAMqE,GAAA;gBACNK,MAAA,EAAQsB,KAAA,CAAMtB,MAAM;gBACpBxE,cAAA;gBACAC,MAAA;gBACAC,cAAA;gBACAC,QAAA;gBACAC,aAAA;gBACAE,QAAA;gBACAC,WAAA;gBACAC,SAAA;gBACAmE,eAAA,EAAiB;gBACjBC,qBAAA,EAAuBhE,eAAA;gBACvBH,UAAA;gBACAE,gBAAA,EAAkBS,UAAA,GAAa,MAAM0E,KAAA,CAAMG,IAAI;gBAC/CpB,WAAA,EACEjD,gBAAA,KAAqB,OACjBA,gBAAA,GACAlB,iBAAA,GAAoBX,KAAA,CAAMkC,IAAI,CAAC,EAAE8D,MAAA,GAASD,KAAA,CAAMG,IAAI,CAAC,KAAK,OACxD,OACAvF,iBAAA,GAAoBX,KAAA,CAAMkC,IAAI,CAAC,EAAE8D,MAAA,GAASD,KAAA,CAAMG,IAAI,CAAC,EAAEzB,MAAA,IAAU,CAAC;gBAC1E1D,WAAA;gBACAC,iBAAA;gBACAC,QAAA;gBACAC,eAAA;gBACAC,aAAA;gBACAC,GAAA;gBACAE,MAAA,EAAQ,OAAO8E,WAAA,KAAgB,WAAWA,WAAA,GAAcrB,SAAA;gBACxDxD,UAAA,EAAY8E,eAAA;gBACZ7E,mBAAA;gBACAC,cAAA;gBACAC;cACF;cAGF;cACA,MAAMsD,WAAA,GAAmB,CAAChE,iBAAA,GAAoBF,IAAA,CAAK,EAAEmD,IAAA,IAAQ,EAAE,EAAES,IAAI,CAClEO,OAAA,IAAYA,OAAA,CAAQzF,EAAE,KAAK4E,GAAA,CAAI5E,EAAE;cAGpC,MAAM0F,MAAA,GAAc;gBAClB1F,EAAA,EAAI4E,GAAA,CAAI5E,EAAE;gBACVsG,SAAA,EAAW1B,GAAA,CAAI0B,SAAS;gBACxBX,SAAA,EAAW;cACb;cAEA,IAAIH,WAAA,EAAajD,gBAAA,EAAkB;gBACjCmD,MAAA,CAAOnD,gBAAgB,GAAGiD,WAAA,CAAYjD,gBAAgB;cACxD;cAEAoC,GAAA,CAAIyB,WAAW,CAACnC,IAAI,CAACyB,MAAA;cAErB,MAAME,WAAA,GAAclG,cAAA,CAAe;gBACjCmG,cAAA,EAAgBtE,WAAA,EAAa0D,MAAA,GAAS3D,IAAA,CAAK,EAAEwE,SAAA;gBAC7CtF,KAAA;gBACAgF,WAAA;gBACAZ;cACF;cAEA,IAAIgB,WAAA,EAAa;gBACfjB,GAAA,CAAIyB,WAAW,CAACzB,GAAA,CAAIyB,WAAW,CAACL,MAAM,GAAG,EAAE,CAACD,SAAS,GAAG;cAC1D;YACF;YAEA,OAAOnB,GAAA;UACT,GACA;YACEH,QAAA,EAAU,EAAE;YACZ4B,WAAA,EAAa;UACf;UAGF,MAAMJ,OAAA,CAAQC,GAAG,CAACzB,QAAA;UAElB;UACA,IAAIjE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,KAAK,MAAM;YAC7BJ,UAAA,CAAW0C,KAAK,GAAG;YACnB1C,UAAA,CAAWkB,YAAY,GAAG;UAC5B,OAAO;YACLlB,UAAA,CAAW0C,KAAK,GAAGrE,cAAA,GAAiBwF,WAAA,GAAcA,WAAA,CAAYJ,MAAM;YACpEzD,UAAA,CAAWkB,YAAY,GAAG7C,cAAA,GAAiBwF,WAAA,GAAcA,WAAA,CAAYJ,MAAM;YAE3E,IAAII,WAAA,CAAYJ,MAAM,GAAG,GAAG;cAC1BzD,UAAA,CAAW4D,eAAe,GAAG;YAC/B;UACF;UAEA5D,UAAA,CAAWmC,IAAI,GAAG2B,WAAA;UAElB;UACA,IAAI,CAACpF,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;YAC7CmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA,KAAK;QAAS;UACZ,IAAI,CAAC5B,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BuC,UAAA,CAAW4D,eAAe,GAAG;YAC7BhE,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA,MAAM4E,WAAA,GAAcpF,MAAA,GAAStB,KAAA,CAAMkC,IAAI,CAAC;UAExC,MAAM/C,aAAA,CAAc;YAClBK,EAAA;YACAC,oBAAA;YACAE,kBAAA,EAAoBK,KAAA,CAAM2E,SAAS,IAAIhF,kBAAA;YACvCC,SAAA;YACAC,oBAAA;YACAC,cAAA;YACAC,IAAA,EAAMA,IAAA,GAAOC,KAAA,CAAMkC,IAAI,CAAC,IAAI,CAAC;YAC7BuC,MAAA,EAAQzE,KAAA,CAAMyE,MAAM;YACpBxE,cAAA;YACAC,MAAA;YACAC,cAAA;YACAC,QAAA;YACAC,aAAA;YACAE,QAAA;YACAC,WAAA;YACAC,SAAA;YACAmE,eAAA,EAAiB;YACjBC,qBAAA,EAAuBhE,eAAA;YACvBH,UAAA,EAAYI,IAAA;YACZF,gBAAA,EAAkBS,UAAA;YAClByD,WAAA,EACE,OAAOjD,gBAAA,KAAqB,YAAYA,gBAAA,GAAmBA,gBAAA,EAAkB4C,MAAA;YAC/E1D,WAAA;YACAC,iBAAA;YACAC,QAAA;YACAC,eAAA;YACAC,aAAA;YACAC,GAAA;YACAE,MAAA,EAAQ,OAAOoF,WAAA,KAAgB,WAAWA,WAAA,GAAc3B,SAAA;YACxDxD,UAAA;YACAC,mBAAA;YACAC,cAAA;YACAC;UACF;UAEA;QACF;MAEA,KAAK;MACL,KAAK;QAAU;UACb,IAAI1B,KAAA,CAAM2G,aAAa,EAAE;YACvB,IAAI,OAAO3G,KAAA,CAAM2G,aAAa,KAAK,UAAU;cAC3C,IAAI,OAAO3G,KAAA,CAAM4G,UAAU,KAAK,UAAU;gBACxC9E,UAAA,CAAW6E,aAAa,GAAG;kBACzB,CAAC3G,KAAA,CAAM4G,UAAU,GAAG5G,KAAA,CAAM2G;gBAC5B;cACF,OAAO;gBACL7E,UAAA,CAAW6E,aAAa,GAAG3G,KAAA,CAAM4G,UAAU,CAAC1C,MAAM,CAAC,CAACC,GAAA,EAAK0C,QAAA;kBACvD1C,GAAG,CAAC0C,QAAA,CAAS,GAAG7G,KAAA,CAAM2G,aAAa;kBACnC,OAAOxC,GAAA;gBACT,GAAG,CAAC;cACN;YACF;YAEA,IAAI,OAAOnE,KAAA,CAAM2G,aAAa,KAAK,YAAY;cAC7C,MAAMG,KAAA,GAAQ,MAAM7H,oBAAA,CAAqBe,KAAA,CAAM2G,aAAa,EAAE;gBAC5DnH,EAAA;gBACAI,SAAA;gBACAG,IAAA,EAAMK,QAAA;gBACNwG,UAAA,EAAY5G,KAAA,CAAM4G,UAAU;gBAC5BxF,GAAA;gBACAkB,WAAA,EAAavC,IAAA;gBACbgH,IAAA,EAAM3F,GAAA,CAAI2F;cACZ;cAEAjF,UAAA,CAAW6E,aAAa,GAAGG,KAAA;YAC7B;UACF;UAEA,IAAI9G,KAAA,CAAMgH,OAAO,EAAE;YACjB,MAAMC,iBAAA,GAAoBpD,KAAA,CAAMC,OAAO,CAAC/D,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,IACpDnC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,CAACgF,GAAG,CAAEC,YAAA;cACpB,IAAItD,KAAA,CAAMC,OAAO,CAAC9D,KAAA,CAAM4G,UAAU,GAAG;gBACnC,OAAO;kBACLA,UAAA,EAAYO,YAAA,CAAaP,UAAU;kBACnCpC,KAAA,EACE2C,YAAA,CAAa3C,KAAK,IAAI,OAAO2C,YAAA,CAAa3C,KAAK,KAAK,WAChD2C,YAAA,CAAa3C,KAAK,EAAEhF,EAAA,GACpB2H,YAAA,CAAa3C;gBACrB;cACF;cACA,IAAI,OAAO2C,YAAA,KAAiB,YAAYA,YAAA,KAAiB,MAAM;gBAC7D,OAAOA,YAAA,CAAa3H,EAAE;cACxB;cACA,OAAO2H,YAAA;YACT,KACApC,SAAA;YAEJjD,UAAA,CAAW0C,KAAK,GAAGyC,iBAAA;YACnBnF,UAAA,CAAWkB,YAAY,GAAGiE,iBAAA;UAC5B,OAAO,IAAIpD,KAAA,CAAMC,OAAO,CAAC9D,KAAA,CAAM4G,UAAU,GAAG;YAC1C,IACE7G,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,IAChB,OAAOnC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,KAAK,YAC5B,gBAAgBnC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,IAChC,WAAWnC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,EAC3B;cACA,MAAMsC,KAAA,GACJ,OAAOzE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,EAAEsC,KAAA,KAAU,YACnCzE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,EAAEsC,KAAA,IAClB,QAAQzE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,CAACsC,KAAK,GAC1BzE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,CAACsC,KAAK,CAAChF,EAAE,GACzBO,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,CAACsC,KAAK;cAC5B,MAAMyC,iBAAA,GAAoB;gBACxBL,UAAA,EAAY7G,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,EAAE0E,UAAA;gBAC9BpC;cACF;cACA1C,UAAA,CAAW0C,KAAK,GAAGyC,iBAAA;cACnBnF,UAAA,CAAWkB,YAAY,GAAGiE,iBAAA;YAC5B;UACF,OAAO;YACL,MAAMA,iBAAA,GACJlH,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,IAAI,OAAOnC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,KAAK,YAAY,QAAQnC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,GAChFnC,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,CAAC1C,EAAE,GACnBO,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC;YACtBJ,UAAA,CAAW0C,KAAK,GAAGyC,iBAAA;YACnBnF,UAAA,CAAWkB,YAAY,GAAGiE,iBAAA;UAC5B;UAEA,IAAI,CAAC/G,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA,KAAK;QAAU;UACb,IAAI,OAAO9B,KAAA,CAAM2G,aAAa,KAAK,YAAY;YAC7C7E,UAAA,CAAWsF,mBAAmB,GAAGpH,KAAA,CAAM2G,aAAa,CAAC;cACnD5G,IAAA,EAAMK,QAAA;cACNiH,OAAA,EAASrH,KAAA,CAAMqH,OAAO;cACtBjG,GAAA;cACAkB,WAAA,EAAavC;YACf;UACF;UAEA,IAAIA,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,KAAK6C,SAAA,EAAW;YAClCjD,UAAA,CAAW0C,KAAK,GAAGzE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC;YACnCJ,UAAA,CAAWkB,YAAY,GAAGjD,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC;UAC5C;UAEA,IAAI,CAAChC,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA;QAAS;UACP,IAAI/B,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC,KAAK6C,SAAA,EAAW;YAClCjD,UAAA,CAAW0C,KAAK,GAAGzE,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC;YACnCJ,UAAA,CAAWkB,YAAY,GAAGjD,IAAI,CAACC,KAAA,CAAMkC,IAAI,CAAC;UAC5C;UAEA;UACA,IAAI,CAAChC,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;IACF;EACF,OAAO,IAAInD,iBAAA,CAAkBqB,KAAA,KAAU,CAACtB,gBAAA,CAAiBsB,KAAA,GAAQ;IAC/D;IAEA,IAAI,CAACE,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;MAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAG;QACZ4E,eAAA,EAAiB;MACnB;MAEA,IAAI7E,eAAA,KAAoB,OAAO;QAC7Ba,KAAK,CAACZ,IAAA,CAAK,CAACD,eAAe,GAAG;MAChC;IACF;IAEA,MAAM1B,aAAA,CAAc;MAClBK,EAAA;MACAe,QAAA;MACAe,MAAA;MACAC,UAAA;MACA;MACA9B,oBAAA,EAAsBC,uBAAA;MACtBC,kBAAA,EAAoBb,gBAAA,CAAiBkB,KAAA,KAAUL,kBAAA;MAC/CC,SAAA;MACAC,oBAAA;MACAC,cAAA;MACAC,IAAA;MACA0E,MAAA,EAAQzE,KAAA,CAAMyE,MAAM;MACpBxE,cAAA;MACAC,MAAA;MACAC,cAAA;MACAC,QAAA;MACAC,aAAA;MACAG,WAAA;MACAC,SAAA;MACAmE,eAAA,EAAiBtE,SAAA;MACjBuE,qBAAA,EAAuBhE,eAAA;MACvBH,UAAA;MACAE,gBAAA;MACAkE,WAAA,EAAanE,iBAAA;MACbI,WAAA;MACAC,iBAAA;MACAC,QAAA;MACAC,eAAA;MACAC,aAAA;MACAC,GAAA;MACAI,mBAAA;MACAC,cAAA;MACAC;IACF;EACF,OAAO,IAAI1B,KAAA,CAAM0C,IAAI,KAAK,QAAQ;IAChC,MAAMsB,QAAA,GAAWhE,KAAA,CAAMsH,IAAI,CAACJ,GAAG,CAAC,CAACK,GAAA,EAAKC,QAAA;MACpC,MAAMC,UAAA,GAAazI,UAAA,CAAWuI,GAAA;MAC9B,IAAIG,SAAA;MAEJ,MAAM;QACJpH,SAAA,EAAWqH,YAAY;QACvB7G,IAAA,EAAM8G,OAAO;QACbvG,UAAA,EAAYwG;MAAa,CAC1B,GAAG9I,aAAA,CAAc;QAChBiB,KAAA,EAAO;UACL,GAAGuH,GAAG;UACN7E,IAAA,EAAM;QACR;QACAoF,KAAA,EAAON,QAAA;QACP5C,eAAA,EAAiBtE,SAAA;QACjBI,UAAA;QACAE;MACF;MAEA,IAAImH,gBAAA,GAA+ChD,SAAA;MAEnD,IAAI0C,UAAA,EAAY;QACd,IAAI9G,iBAAA,KAAsB,MAAM;UAC9BoH,gBAAA,GAAmB;QACrB,OAAO;UACL,MAAMC,cAAA,GAAiBrH,iBAAA,GAAoB4G,GAAA,CAAIrF,IAAI,CAAC;UACpD,IAAI8F,cAAA,KAAmB,MAAM;YAC3BD,gBAAA,GAAmB;UACrB,OAAO;YACLA,gBAAA,GAAmBC,cAAA,EAAgBvD,MAAA;UACrC;QACF;QAEA,IAAI,OAAOnD,MAAA,GAASiG,GAAA,CAAIrF,IAAI,CAAC,KAAK,UAAU;UAC1CwF,SAAA,GAAYpG,MAAA,GAASiG,GAAA,CAAIrF,IAAI,CAAC;QAChC;MACF,OAAO;QACL6F,gBAAA,GAAmBpH,iBAAA;QACnB+G,SAAA,GAAYpG,MAAA;MACd;MAEA,MAAM2G,YAAA,GAAenH,IAAA,GAAOA,IAAA,CAAKoH,KAAK,CAAC,OAAO,EAAE;MAEhD;MACA;MACA,IAAIC,kBAAA,GAAqBtH,eAAA;MAEzB,IAAIA,eAAA,IAAmB,OAAO0G,GAAA,CAAIa,KAAK,EAAEC,SAAA,KAAc,YAAY;QACjEF,kBAAA,GAAqBZ,GAAA,CAAIa,KAAK,CAACC,SAAS,CAACjI,QAAA,EAAUL,IAAA,EAAM;UACvDH,SAAA;UACAa,SAAA;UACAK,IAAA,EAAMmH,YAAA;UACNlB,IAAA,EAAM3F,GAAA,CAAI2F;QACZ;MACF;MAEA,IAAIQ,GAAA,EAAK/H,EAAA,EAAI;QACXkC,KAAK,CAAC6F,GAAA,CAAI/H,EAAE,CAAC,GAAG;UACdqB,eAAA,EAAiBsH;QACnB;MACF;MAEA,OAAOhJ,aAAA,CAAc;QACnBK,EAAA;QACAC,oBAAA,EAAsBC,uBAAA;QACtBC,kBAAA,EAAoB4H,GAAA,CAAI5C,SAAS,IAAIhF,kBAAA;QACrCC,SAAA;QACAC,oBAAA;QACAC,cAAA;QACAC,IAAA,EAAM0H,UAAA,GAAa1H,IAAA,GAAOwH,GAAA,CAAIrF,IAAI,CAAC,IAAI,CAAC,IAAInC,IAAA;QAC5C0E,MAAA,EAAQ8C,GAAA,CAAI9C,MAAM;QAClBxE,cAAA;QACAC,MAAA;QACAC,cAAA;QACAC,QAAA;QACAC,aAAA;QACAE,QAAA;QACAC,WAAA;QACAC,SAAA;QACAmE,eAAA,EAAiB6C,UAAA,GAAa,KAAKE,YAAA;QACnC9C,qBAAA,EAAuBsD,kBAAA;QACvBzH,UAAA,EAAY+G,UAAA,GAAaG,OAAA,GAAUlH,UAAA;QACnCE,gBAAA,EAAkB6G,UAAA,GAAaI,aAAA,GAAgBjH,gBAAA;QAC/CkE,WAAA,EAAaiD,gBAAA;QACbhH,WAAA;QACAC,iBAAA;QACAC,QAAA;QACAC,eAAA;QACAC,aAAA;QACAC,GAAA;QACAE,MAAA,EAAQoG,SAAA;QACRnG,UAAA;QACAC,mBAAA;QACAC,cAAA;QACAC;MACF;IACF;IAEA,MAAM8D,OAAA,CAAQC,GAAG,CAACzB,QAAA;EACpB,OAAO,IAAIhE,KAAA,CAAM0C,IAAI,KAAK,MAAM;IAC9B,IAAI,CAACxC,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;MAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;MACdJ,KAAK,CAACZ,IAAA,CAAK,CAAC4E,eAAe,GAAG;IAChC;EACF;EAEA,IAAIvE,aAAA,IAAiB,CAACvC,uBAAA,CAAwBoB,KAAA,GAAQ;IACpD,MAAMsI,WAAA,GAAcrI,cAAA,CAAesI,GAAG,CAAClH,UAAA;IAEvC,IAAI,CAACiH,WAAA,IAAe,CAAC/H,QAAA,EAAU;MAC7B,IAAIc,UAAA,CAAWmH,QAAQ,CAAC,eAAe;QACrC;MACF,OAAO;QACL,MAAM,IAAIrC,KAAA,CAAM,8BAA8B9E,UAAA,EAAY;MAC5D;IACF;IAEA,IAAI,CAACK,KAAK,CAACZ,IAAA,CAAK,EAAE;MAChB;MACA;MACA;IACF;IAEA,IAAIkB,aAAA,EAAe;MACjBN,KAAK,CAACZ,IAAA,CAAK,CAACkB,aAAa,GAAGA,aAAA;IAC9B;IAEAb,aAAA,CAAc;MACZ3B,EAAA;MACAK,oBAAA;MACAC,cAAA;MACAC,IAAA,EAAMK,QAAA;MACNkI,WAAA,EAAaA,WAAA;MACbrI,cAAA;MACA6B,UAAA,EAAYJ,KAAK,CAACZ,IAAA,CAAK;MACvB2H,SAAA,EAAW/G,KAAA;MACXpB,SAAA;MACAyB,gBAAA;MACAxB,QAAA;MACAE,SAAA;MACAC,UAAA;MACAE,gBAAA;MACAE,IAAA;MACAgE,WAAA,EAAajD,gBAAA;MACbd,WAAA;MACA2H,kBAAA,EAAoB1H,iBAAA,GAAoBF,IAAA,CAAK;MAC7CG,QAAA;MACAC,eAAA;MACAE,GAAA;MACAC,UAAA;MACAiB,WAAA,EAAavC;IACf;EACF;AACF","ignoreList":[]}