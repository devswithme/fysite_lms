{"version":3,"sources":["../../../src/postgres/createJSONQuery/index.ts"],"sourcesContent":["import type { CreateJSONQueryArgs } from '../../types.js'\n\nconst operatorMap: Record<string, string> = {\n  contains: '~',\n  equals: '==',\n  in: 'in',\n  like: 'like_regex',\n  not_equals: '!=',\n  not_in: 'in',\n  not_like: '!like_regex',\n}\n\nconst sanitizeValue = (value: unknown, operator?: string) => {\n  if (typeof value === 'string') {\n    // ignore casing with like or not_like\n    return `\"${['like', 'not_like'].includes(operator) ? '(?i)' : ''}${value}\"`\n  }\n\n  return value as string\n}\n\nexport const createJSONQuery = ({ column, operator, pathSegments, value }: CreateJSONQueryArgs) => {\n  const columnName = typeof column === 'object' ? column.name : column\n  const jsonPaths = pathSegments\n    .slice(1)\n    .map((key) => {\n      return `${key}[*]`\n    })\n    .join('.')\n\n  let sql = ''\n\n  if (['in', 'not_in'].includes(operator) && Array.isArray(value)) {\n    value.forEach((item, i) => {\n      sql = `${sql}${createJSONQuery({ column, operator: operator === 'in' ? 'equals' : 'not_equals', pathSegments, value: item })}${i === value.length - 1 ? '' : ` ${operator === 'in' ? 'OR' : 'AND'} `}`\n    })\n  } else if (operator === 'exists') {\n    sql = `${value === false ? 'NOT ' : ''}jsonb_path_exists(${columnName}, '$.${jsonPaths}')`\n  } else if (['not_like'].includes(operator)) {\n    const mappedOperator = operatorMap[operator]\n\n    sql = `NOT jsonb_path_exists(${columnName}, '$.${jsonPaths} ? (@ ${mappedOperator.substring(1)} ${sanitizeValue(value, operator)})')`\n  } else {\n    sql = `jsonb_path_exists(${columnName}, '$.${jsonPaths} ? (@ ${operatorMap[operator]} ${sanitizeValue(value, operator)})')`\n  }\n\n  return sql\n}\n"],"names":["operatorMap","contains","equals","in","like","not_equals","not_in","not_like","sanitizeValue","value","operator","includes","createJSONQuery","column","pathSegments","columnName","name","jsonPaths","slice","map","key","join","sql","Array","isArray","forEach","item","i","length","mappedOperator","substring"],"mappings":"AAEA,MAAMA,cAAsC;IAC1CC,UAAU;IACVC,QAAQ;IACRC,IAAI;IACJC,MAAM;IACNC,YAAY;IACZC,QAAQ;IACRC,UAAU;AACZ;AAEA,MAAMC,gBAAgB,CAACC,OAAgBC;IACrC,IAAI,OAAOD,UAAU,UAAU;QAC7B,sCAAsC;QACtC,OAAO,CAAC,CAAC,EAAE;YAAC;YAAQ;SAAW,CAACE,QAAQ,CAACD,YAAY,SAAS,KAAKD,MAAM,CAAC,CAAC;IAC7E;IAEA,OAAOA;AACT;AAEA,OAAO,MAAMG,kBAAkB,CAAC,EAAEC,MAAM,EAAEH,QAAQ,EAAEI,YAAY,EAAEL,KAAK,EAAuB;IAC5F,MAAMM,aAAa,OAAOF,WAAW,WAAWA,OAAOG,IAAI,GAAGH;IAC9D,MAAMI,YAAYH,aACfI,KAAK,CAAC,GACNC,GAAG,CAAC,CAACC;QACJ,OAAO,GAAGA,IAAI,GAAG,CAAC;IACpB,GACCC,IAAI,CAAC;IAER,IAAIC,MAAM;IAEV,IAAI;QAAC;QAAM;KAAS,CAACX,QAAQ,CAACD,aAAaa,MAAMC,OAAO,CAACf,QAAQ;QAC/DA,MAAMgB,OAAO,CAAC,CAACC,MAAMC;YACnBL,MAAM,GAAGA,MAAMV,gBAAgB;gBAAEC;gBAAQH,UAAUA,aAAa,OAAO,WAAW;gBAAcI;gBAAcL,OAAOiB;YAAK,KAAKC,MAAMlB,MAAMmB,MAAM,GAAG,IAAI,KAAK,CAAC,CAAC,EAAElB,aAAa,OAAO,OAAO,MAAM,CAAC,CAAC,EAAE;QACxM;IACF,OAAO,IAAIA,aAAa,UAAU;QAChCY,MAAM,GAAGb,UAAU,QAAQ,SAAS,GAAG,kBAAkB,EAAEM,WAAW,KAAK,EAAEE,UAAU,EAAE,CAAC;IAC5F,OAAO,IAAI;QAAC;KAAW,CAACN,QAAQ,CAACD,WAAW;QAC1C,MAAMmB,iBAAiB7B,WAAW,CAACU,SAAS;QAE5CY,MAAM,CAAC,sBAAsB,EAAEP,WAAW,KAAK,EAAEE,UAAU,MAAM,EAAEY,eAAeC,SAAS,CAAC,GAAG,CAAC,EAAEtB,cAAcC,OAAOC,UAAU,GAAG,CAAC;IACvI,OAAO;QACLY,MAAM,CAAC,kBAAkB,EAAEP,WAAW,KAAK,EAAEE,UAAU,MAAM,EAAEjB,WAAW,CAACU,SAAS,CAAC,CAAC,EAAEF,cAAcC,OAAOC,UAAU,GAAG,CAAC;IAC7H;IAEA,OAAOY;AACT,EAAC"}