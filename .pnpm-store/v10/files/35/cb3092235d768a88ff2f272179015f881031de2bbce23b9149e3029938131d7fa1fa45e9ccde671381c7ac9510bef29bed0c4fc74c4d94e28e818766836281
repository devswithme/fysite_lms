{"version":3,"sources":["../../src/upsertRow/index.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { SelectedFields } from 'drizzle-orm/sqlite-core'\nimport type { TypeWithID } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport { ValidationError } from 'payload'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { insertArrays } from './insertArrays.js'\nimport { shouldUseOptimizedUpsertRow } from './shouldUseOptimizedUpsertRow.js'\n\n/**\n * If `id` is provided, it will update the row with that ID.\n * If `where` is provided, it will update the row that matches the `where`\n * If neither `id` nor `where` is provided, it will create a new row.\n *\n * adapter function replaces the entire row and does not support partial updates.\n */\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  data,\n  db,\n  fields,\n  ignoreResult,\n  // TODO:\n  // When we support joins for write operations (create/update) - pass collectionSlug to the buildFindManyArgs\n  // Make a new argument in upsertRow.ts and pass the slug from every operation.\n  joinQuery: _joinQuery,\n  operation,\n  path = '',\n  req,\n  select,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  let insertedRow: Record<string, unknown> = { id }\n  if (id && shouldUseOptimizedUpsertRow({ data, fields })) {\n    const { row } = transformForWrite({\n      adapter,\n      data,\n      enableAtomicWrites: true,\n      fields,\n      tableName,\n    })\n\n    const drizzle = db as LibSQLDatabase\n\n    if (ignoreResult) {\n      await drizzle\n        .update(adapter.tables[tableName])\n        .set(row)\n        .where(eq(adapter.tables[tableName].id, id))\n      return ignoreResult === 'idOnly' ? ({ id } as T) : null\n    }\n\n    const findManyArgs = buildFindManyArgs({\n      adapter,\n      depth: 0,\n      fields,\n      joinQuery: false,\n      select,\n      tableName,\n    })\n\n    const findManyKeysLength = Object.keys(findManyArgs).length\n    const hasOnlyColumns = Object.keys(findManyArgs.columns || {}).length > 0\n\n    if (findManyKeysLength === 0 || hasOnlyColumns) {\n      // Optimization - No need for joins => can simply use returning(). This is optimal for very simple collections\n      // without complex fields that live in separate tables like blocks, arrays, relationships, etc.\n\n      const selectedFields: SelectedFields = {}\n      if (hasOnlyColumns) {\n        for (const [column, enabled] of Object.entries(findManyArgs.columns)) {\n          if (enabled) {\n            selectedFields[column] = adapter.tables[tableName][column]\n          }\n        }\n      }\n\n      const docs = await drizzle\n        .update(adapter.tables[tableName])\n        .set(row)\n        .where(eq(adapter.tables[tableName].id, id))\n        .returning(Object.keys(selectedFields).length ? selectedFields : undefined)\n\n      return transform<T>({\n        adapter,\n        config: adapter.payload.config,\n        data: docs[0],\n        fields,\n        joinQuery: false,\n        tableName,\n      })\n    }\n\n    // DB Update that needs the result, potentially with joins => need to update first, then find. returning() does not work with joins.\n\n    await drizzle\n      .update(adapter.tables[tableName])\n      .set(row)\n      .where(eq(adapter.tables[tableName].id, id))\n\n    findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n    const doc = await db.query[tableName].findFirst(findManyArgs)\n\n    return transform<T>({\n      adapter,\n      config: adapter.payload.config,\n      data: doc,\n      fields,\n      joinQuery: false,\n      tableName,\n    })\n  }\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    enableAtomicWrites: false,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      if (id) {\n        rowToInsert.row.id = id\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target },\n          tableName,\n          values: rowToInsert.row,\n        })\n      } else {\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target, where },\n          tableName,\n          values: rowToInsert.row,\n        })\n      }\n    } else {\n      if (adapter.allowIDOnCreate && data.id) {\n        rowToInsert.row.id = data.id\n      }\n      ;[insertedRow] = await adapter.insert({\n        db,\n        tableName,\n        values: rowToInsert.row,\n      })\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectsToInsert[selectTableName] = []\n\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((tableName) => {\n      rowToInsert.blocks[tableName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[tableName]) {\n          blocksToInsert[tableName] = []\n        }\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[tableName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTableName = `${tableName}${adapter.localesSuffix}`\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: localeTableName,\n          where: eq(localeTable._parentID, insertedRow.id),\n        })\n      }\n\n      await adapter.insert({\n        db,\n        tableName: localeTableName,\n        values: localesToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...rowToInsert.relationshipsToDelete],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: relationshipsTableName,\n        values: relationsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...textsToInsert, ...rowToInsert.textsToDelete],\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: textsTableName,\n        values: textsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...numbersToInsert, ...rowToInsert.numbersToDelete],\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: numbersTableName,\n        values: numbersToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const tableName of rowToInsert.blocksToDelete) {\n        const blockTable = adapter.tables[tableName]\n        await adapter.deleteWhere({\n          db,\n          tableName,\n          where: eq(blockTable._parentID, insertedRow.id),\n        })\n      }\n    }\n\n    // When versions are enabled, adapter is used to track mapping between blocks/arrays ObjectID to their numeric generated representation, then we use it for nested to arrays/blocks select hasMany in versions.\n    const arraysBlocksUUIDMap: Record<string, number | string> = {}\n\n    for (const [tableName, blockRows] of Object.entries(blocksToInsert)) {\n      insertedBlockRows[tableName] = await adapter.insert({\n        db,\n        tableName,\n        values: blockRows.map(({ row }) => row),\n      })\n\n      insertedBlockRows[tableName].forEach((row, i) => {\n        blockRows[i].row = row\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          arraysBlocksUUIDMap[row._uuid] = row.id\n        }\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await adapter.insert({\n          db,\n          tableName: `${tableName}${adapter.localesSuffix}`,\n          values: blockLocaleRowsToInsert,\n        })\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[tableName],\n        uuidMap: arraysBlocksUUIDMap,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays],\n      db,\n      parentRows: [insertedRow],\n      uuidMap: arraysBlocksUUIDMap,\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: selectTableName,\n          where: eq(selectTable.parent, insertedRow.id),\n        })\n      }\n\n      if (Object.keys(arraysBlocksUUIDMap).length > 0) {\n        tableRows.forEach((row: any) => {\n          if (row.parent in arraysBlocksUUIDMap) {\n            row.parent = arraysBlocksUUIDMap[row.parent]\n          }\n        })\n      }\n\n      if (tableRows.length) {\n        await adapter.insert({\n          db,\n          tableName: selectTableName,\n          values: tableRows,\n        })\n      }\n    }\n\n    // //////////////////////////////////\n    // Error Handling\n    // //////////////////////////////////\n  } catch (caughtError) {\n    // Unique constraint violation error\n    // '23505' is the code for PostgreSQL, and 'SQLITE_CONSTRAINT_UNIQUE' is for SQLite\n\n    let error = caughtError\n    if (typeof caughtError === 'object' && 'cause' in caughtError) {\n      error = caughtError.cause\n    }\n\n    if (error.code === '23505' || error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n      let fieldName: null | string = null\n      // We need to try and find the right constraint for the field but if we can't we fallback to a generic message\n      if (error.code === '23505') {\n        // For PostgreSQL, we can try to extract the field name from the error constraint\n        if (adapter.fieldConstraints?.[tableName]?.[error.constraint]) {\n          fieldName = adapter.fieldConstraints[tableName]?.[error.constraint]\n        } else {\n          const replacement = `${tableName}_`\n\n          if (error.constraint.includes(replacement)) {\n            const replacedConstraint = error.constraint.replace(replacement, '')\n\n            if (replacedConstraint && adapter.fieldConstraints[tableName]?.[replacedConstraint]) {\n              fieldName = adapter.fieldConstraints[tableName][replacedConstraint]\n            }\n          }\n        }\n\n        if (!fieldName) {\n          // Last case scenario we extract the key and value from the detail on the error\n          const detail = error.detail\n          const regex = /Key \\(([^)]+)\\)=\\(([^)]+)\\)/\n          const match: string[] = detail.match(regex)\n\n          if (match && match[1]) {\n            const key = match[1]\n\n            fieldName = key\n          }\n        }\n      } else if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n        /**\n         * For SQLite, we can try to extract the field name from the error message\n         * The message typically looks like:\n         * \"UNIQUE constraint failed: table_name.field_name\"\n         */\n        const regex = /UNIQUE constraint failed: ([^.]+)\\.([^.]+)/\n        const match: string[] = error.message.match(regex)\n\n        if (match && match[2]) {\n          if (adapter.fieldConstraints[tableName]) {\n            fieldName = adapter.fieldConstraints[tableName][`${match[2]}_idx`]\n          }\n\n          if (!fieldName) {\n            fieldName = match[2]\n          }\n        }\n      }\n\n      throw new ValidationError(\n        {\n          id,\n          errors: [\n            {\n              message: req?.t ? req.t('error:valueMustBeUnique') : 'Value must be unique',\n              path: fieldName,\n            },\n          ],\n          req,\n        },\n        req?.t,\n      )\n    } else {\n      throw error\n    }\n  }\n\n  if (ignoreResult === 'idOnly') {\n    return { id: insertedRow.id } as T\n  }\n\n  if (ignoreResult) {\n    return data as T\n  }\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery: false,\n    select,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n    joinQuery: false,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["eq","ValidationError","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","insertArrays","shouldUseOptimizedUpsertRow","upsertRow","id","adapter","data","db","fields","ignoreResult","joinQuery","_joinQuery","operation","path","req","select","tableName","upsertTarget","where","insertedRow","row","enableAtomicWrites","drizzle","update","tables","set","findManyArgs","depth","findManyKeysLength","Object","keys","length","hasOnlyColumns","columns","selectedFields","column","enabled","entries","docs","returning","undefined","config","payload","doc","query","findFirst","rowToInsert","target","insert","onConflictDoUpdate","values","allowIDOnCreate","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","locales","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockRow","uuid","localeTableName","localesSuffix","localeTable","deleteWhere","relationshipsTableName","relationshipsSuffix","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToDelete","textsTableName","textsToDelete","numbersTableName","numbersToDelete","insertedBlockRows","blocksToDelete","blockTable","arraysBlocksUUIDMap","blockRows","map","i","_uuid","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrays","parentRows","uuidMap","arrayTableName","tableRows","selectTable","caughtError","error","cause","code","fieldName","fieldConstraints","constraint","replacement","includes","replacedConstraint","replace","detail","regex","match","key","message","errors","t","result"],"mappings":"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"}