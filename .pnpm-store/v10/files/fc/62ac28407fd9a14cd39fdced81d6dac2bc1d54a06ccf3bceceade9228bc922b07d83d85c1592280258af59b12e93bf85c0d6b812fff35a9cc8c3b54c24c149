{"version":3,"sources":["../../../src/transform/write/traverseFields.ts"],"sourcesContent":["import { sql } from 'drizzle-orm'\nimport { APIError, type FlattenedField } from 'payload'\nimport { fieldIsVirtual, fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type {\n  ArrayRowToInsert,\n  BlockRowToInsert,\n  NumberToDelete,\n  RelationshipToDelete,\n  TextToDelete,\n} from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { resolveBlockTableName } from '../../utilities/validateExistingBlockIsIdentical.js'\nimport { transformArray } from './array.js'\nimport { transformBlocks } from './blocks.js'\nimport { transformNumbers } from './numbers.js'\nimport { transformRelationship } from './relationships.js'\nimport { transformSelects } from './selects.js'\nimport { transformTexts } from './texts.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrays: {\n    [tableName: string]: ArrayRowToInsert[]\n  }\n  /**\n   * This is the name of the base table\n   */\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  /**\n   * A snake-case field prefix, representing prior fields\n   * Ex: my_group_my_named_tab_\n   */\n  columnPrefix: string\n  data: Record<string, unknown>\n  enableAtomicWrites?: boolean\n  existingLocales?: Record<string, unknown>[]\n  /**\n   * A prefix that will retain camel-case formatting, representing prior fields\n   * Ex: myGroup_myNamedTab_\n   */\n  fieldPrefix: string\n  fields: FlattenedField[]\n  forcedLocale?: string\n  /**\n   * Tracks whether the current traversion context is from array or block.\n   */\n  insideArrayOrBlock?: boolean\n  locales: {\n    [locale: string]: Record<string, unknown>\n  }\n  numbers: Record<string, unknown>[]\n  numbersToDelete: NumberToDelete[]\n  parentIsLocalized: boolean\n  /**\n   * This is the name of the parent table\n   */\n  parentTableName: string\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  row: Record<string, unknown>\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  textsToDelete: TextToDelete[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const traverseFields = ({\n  adapter,\n  arrays,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  columnPrefix,\n  data,\n  enableAtomicWrites,\n  existingLocales,\n  fieldPrefix,\n  fields,\n  forcedLocale,\n  insideArrayOrBlock = false,\n  locales,\n  numbers,\n  numbersToDelete,\n  parentIsLocalized,\n  parentTableName,\n  path,\n  relationships,\n  relationshipsToDelete,\n  row,\n  selects,\n  texts,\n  textsToDelete,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  if (row._uuid) {\n    data._uuid = row._uuid\n  }\n\n  fields.forEach((field) => {\n    let columnName = ''\n    let fieldName = ''\n    let fieldData: unknown\n\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    columnName = `${columnPrefix || ''}${toSnakeCase(field.name)}`\n    fieldName = `${fieldPrefix || ''}${field.name}`\n    fieldData = data[field.name]\n\n    const isLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n\n      if (!arrays[arrayTableName]) {\n        arrays[arrayTableName] = []\n      }\n\n      if (isLocalized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformArray({\n                adapter,\n                arrayTableName,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                numbersToDelete,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                textsToDelete,\n                withinArrayOrBlockLocale: localeKey,\n              })\n\n              arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n            }\n          })\n        }\n      } else {\n        const newRows = transformArray({\n          adapter,\n          arrayTableName,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: data[field.name],\n          field,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n\n        arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    if (field.type === 'blocks' && !adapter.blocksAsJSON) {\n      ;(field.blockReferences ?? field.blocks).forEach((block) => {\n        const matchedBlock =\n          typeof block === 'string'\n            ? adapter.payload.config.blocks.find((each) => each.slug === block)\n            : block\n\n        blocksToDelete.add(\n          resolveBlockTableName(\n            matchedBlock,\n            adapter.tableNameMap.get(`${baseTableName}_blocks_${toSnakeCase(matchedBlock.slug)}`),\n          ),\n        )\n      })\n\n      if (isLocalized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformBlocks({\n                adapter,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                numbersToDelete,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                textsToDelete,\n                withinArrayOrBlockLocale: localeKey,\n              })\n            }\n          })\n        }\n      } else if (isArrayOfRows(fieldData)) {\n        transformBlocks({\n          adapter,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: fieldData,\n          field,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'group' || field.type === 'tab') {\n      if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n        if (isLocalized) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            // preserve array ID if there is\n            localeData._uuid = data.id || data._uuid\n\n            traverseFields({\n              adapter,\n              arrays,\n              baseTableName,\n              blocks,\n              blocksToDelete,\n              columnPrefix: `${columnName}_`,\n              data: localeData as Record<string, unknown>,\n              enableAtomicWrites,\n              existingLocales,\n              fieldPrefix: `${fieldName}_`,\n              fields: field.flattenedFields,\n              forcedLocale: localeKey,\n              insideArrayOrBlock,\n              locales,\n              numbers,\n              numbersToDelete,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentTableName,\n              path: `${path || ''}${field.name}.`,\n              relationships,\n              relationshipsToDelete,\n              row,\n              selects,\n              texts,\n              textsToDelete,\n              withinArrayOrBlockLocale: localeKey,\n            })\n          })\n        } else {\n          // preserve array ID if there is\n          const groupData = data[field.name] as Record<string, unknown>\n          groupData._uuid = data.id || data._uuid\n\n          traverseFields({\n            adapter,\n            arrays,\n            baseTableName,\n            blocks,\n            blocksToDelete,\n            columnPrefix: `${columnName}_`,\n            data: groupData,\n            existingLocales,\n            fieldPrefix: `${fieldName}_`,\n            fields: field.flattenedFields,\n            insideArrayOrBlock,\n            locales,\n            numbers,\n            numbersToDelete,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentTableName,\n            path: `${path || ''}${field.name}.`,\n            relationships,\n            relationshipsToDelete,\n            row,\n            selects,\n            texts,\n            textsToDelete,\n            withinArrayOrBlockLocale,\n          })\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      const relationshipPath = `${path || ''}${field.name}`\n\n      if (\n        isLocalized &&\n        (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany))\n      ) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (localeData === null) {\n              relationshipsToDelete.push({\n                locale: localeKey,\n                path: relationshipPath,\n              })\n              return\n            }\n\n            transformRelationship({\n              baseRow: {\n                locale: localeKey,\n                path: relationshipPath,\n              },\n              data: localeData,\n              field,\n              relationships,\n            })\n          })\n        }\n        return\n      } else if (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany)) {\n        if (fieldData === null || (Array.isArray(fieldData) && fieldData.length === 0)) {\n          relationshipsToDelete.push({ path: relationshipPath })\n          return\n        }\n\n        transformRelationship({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: relationshipPath,\n          },\n          data: fieldData,\n          field,\n          relationships,\n        })\n        return\n      } else {\n        if (\n          !isLocalized &&\n          fieldData &&\n          typeof fieldData === 'object' &&\n          'id' in fieldData &&\n          fieldData?.id\n        ) {\n          fieldData = fieldData.id\n        } else if (isLocalized) {\n          if (typeof fieldData === 'object') {\n            Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n              if (typeof localeData === 'object') {\n                if (localeData && 'id' in localeData && localeData?.id) {\n                  fieldData[localeKey] = localeData.id\n                }\n              } else {\n                fieldData[localeKey] = localeData\n              }\n            })\n          }\n        }\n      }\n    }\n\n    if (field.type === 'text' && field.hasMany) {\n      const textPath = `${path || ''}${field.name}`\n\n      if (isLocalized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              if (!localeData.length) {\n                textsToDelete.push({ locale: localeKey, path: textPath })\n                return\n              }\n\n              transformTexts({\n                baseRow: {\n                  locale: localeKey,\n                  path: textPath,\n                },\n                data: localeData,\n                texts,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        if (!fieldData.length) {\n          textsToDelete.push({ locale: withinArrayOrBlockLocale, path: textPath })\n          return\n        }\n\n        transformTexts({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: textPath,\n          },\n          data: fieldData,\n          texts,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPath = `${path || ''}${field.name}`\n\n      if (isLocalized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              if (!localeData.length) {\n                numbersToDelete.push({ locale: localeKey, path: numberPath })\n                return\n              }\n\n              transformNumbers({\n                baseRow: {\n                  locale: localeKey,\n                  path: numberPath,\n                },\n                data: localeData,\n                numbers,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        if (!fieldData.length) {\n          numbersToDelete.push({ locale: withinArrayOrBlockLocale, path: numberPath })\n          return\n        }\n\n        transformNumbers({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: numberPath,\n          },\n          data: fieldData,\n          numbers,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      const selectTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n      if (!selects[selectTableName]) {\n        selects[selectTableName] = []\n      }\n\n      if (isLocalized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformSelects({\n                id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n                data: localeData,\n                locale: localeKey,\n              })\n\n              selects[selectTableName] = selects[selectTableName].concat(newRows)\n            }\n          })\n        }\n      } else if (Array.isArray(data[field.name])) {\n        const newRows = transformSelects({\n          id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n          data: data[field.name],\n          locale: withinArrayOrBlockLocale,\n        })\n\n        selects[selectTableName] = selects[selectTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    const valuesToTransform: { localeKey?: string; ref: unknown; value: unknown }[] = []\n\n    if (isLocalized) {\n      if (typeof fieldData === 'object' && fieldData !== null) {\n        Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n          if (!locales[localeKey]) {\n            locales[localeKey] = {}\n          }\n\n          valuesToTransform.push({\n            localeKey,\n            ref: locales,\n            value: localeData,\n          })\n        })\n      }\n    } else {\n      let ref = row\n\n      if (forcedLocale) {\n        if (!locales[forcedLocale]) {\n          locales[forcedLocale] = {}\n        }\n        ref = locales[forcedLocale]\n      }\n\n      valuesToTransform.push({ ref, value: fieldData })\n    }\n\n    valuesToTransform.forEach(({ localeKey, ref, value }) => {\n      let formattedValue = value\n\n      if (typeof value !== 'undefined') {\n        if (value && field.type === 'point' && adapter.name !== 'sqlite') {\n          formattedValue = sql`ST_GeomFromGeoJSON(${JSON.stringify(value)})`\n        }\n\n        if (field.type === 'text' && value && typeof value !== 'string') {\n          formattedValue = JSON.stringify(value)\n        }\n\n        if (\n          field.type === 'number' &&\n          value &&\n          typeof value === 'object' &&\n          '$inc' in value &&\n          typeof value.$inc === 'number'\n        ) {\n          if (!enableAtomicWrites) {\n            throw new APIError(\n              'The passed data must not contain any nested fields for atomic writes',\n            )\n          }\n\n          formattedValue = sql.raw(`${columnName} + ${value.$inc}`)\n        }\n\n        if (field.type === 'date') {\n          if (typeof value === 'number' && !Number.isNaN(value)) {\n            formattedValue = new Date(value).toISOString()\n          } else if (value instanceof Date) {\n            formattedValue = value.toISOString()\n          }\n        }\n      }\n\n      if (field.type === 'date' && fieldName === 'updatedAt') {\n        // let the db handle this\n        formattedValue = new Date().toISOString()\n      }\n\n      if (typeof formattedValue !== 'undefined') {\n        if (localeKey) {\n          ref[localeKey][fieldName] = formattedValue\n        } else {\n          ref[fieldName] = formattedValue\n        }\n      }\n    })\n  })\n}\n"],"names":["sql","APIError","fieldIsVirtual","fieldShouldBeLocalized","toSnakeCase","isArrayOfRows","resolveBlockTableName","transformArray","transformBlocks","transformNumbers","transformRelationship","transformSelects","transformTexts","traverseFields","adapter","arrays","baseTableName","blocks","blocksToDelete","columnPrefix","data","enableAtomicWrites","existingLocales","fieldPrefix","fields","forcedLocale","insideArrayOrBlock","locales","numbers","numbersToDelete","parentIsLocalized","parentTableName","path","relationships","relationshipsToDelete","row","selects","texts","textsToDelete","withinArrayOrBlockLocale","_uuid","forEach","field","columnName","fieldName","fieldData","name","isLocalized","type","arrayTableName","tableNameMap","get","Object","entries","localeKey","localeData","Array","isArray","newRows","locale","localized","concat","blocksAsJSON","blockReferences","block","matchedBlock","payload","config","find","each","slug","add","id","flattenedFields","groupData","relationshipPath","relationTo","hasMany","push","baseRow","length","textPath","numberPath","selectTableName","undefined","valuesToTransform","ref","value","formattedValue","JSON","stringify","$inc","raw","Number","isNaN","Date","toISOString"],"mappings":"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"}